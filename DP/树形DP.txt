1.入门题:没有上司的舞会
某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。
思路：dp[x][0]、dp[x][1]表示以x为根的子树且选和不选x的最大值。dp[x][0]+=max(dp[v][1],dp[v][0](v为x的所有孩子)，dp[x][1]+=∑dp[v][0]。
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e4;
int r[maxn],in[maxn],dp[maxn][2];
vector<int> g[maxn];
void dfs(int now)
{
    dp[now][0]=0;
    dp[now][1]=r[now];
    for(int i=0;i<g[now].size();i++)
    {
        int v=g[now][i];
        dfs(v);
        dp[now][0]+=max(dp[v][1],dp[v][0]);
        dp[now][1]+=dp[v][0];
    }
}
int main()
{
    std::ios::sync_with_stdio(false);
    int n;
    cin>>n;
    for(int i=1; i<=n; i++)
        cin>>r[i];
    int u,v;
    while(cin>>u>>v&&u+v)
    {
        g[v].push_back(u);
        in[u]++;
    }
    int root;
    for(int i=1; i<=n; i++)
    {
        if(!in[i])
        {
            root=i;
            break;
        }
    }
    dfs(root);
    cout<<max(dp[root][0],dp[root][1])<<endl;
    return 0;
}
2.树形背包(洛谷p2014)
现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long
const int maxn=1e3;
struct node
{
    int to,val;
};
vector<node> g[maxn];
int n,m,s[maxn],dp[maxn][maxn],num[maxn];
void dfs(int u,int fa)
{
    num[u]=1;
    dp[u][1]=s[u];
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i].to;
        if(v==fa) continue;
        dfs(v,u);
        for(int j=num[u];j;j--)
        {
            for(int k=1;k<=num[v];k++)
            {
                dp[u][j+k]=max(dp[u][j+k],dp[u][j]+dp[v][k]);
            }
        }
        num[u]+=num[v];
    }
}
int main()
{
    std::ios::sync_with_stdio(false);
    while(cin>>n>>m)
    {
        memset(num,0,sizeof(num));
        memset(dp,0,sizeof(dp));
        memset(s,0,sizeof(s));
        m++;
        for(int i=1;i<=n;i++)
        {
            int k;
            cin>>k>>s[i];
            g[k].push_back({i,0});
        }
        dfs(0,-1);
        cout<<dp[0][m]<<endl;
    }
    return 0;
}

3.树形背包(边权)(洛谷p2015)
题意：有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点）。这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。给定需要保留的树枝数量，求出最多能留住多少苹果。
思路：将要保留的边的数量++，就转化成删除等量的点了。方法和上题类似，注意边权转化成点权是给to这个点。
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long
const int maxn=1e3;
struct node
{
    int to,val;
};
vector<node> g[maxn];
int n,m,s[maxn],dp[maxn][maxn],num[maxn];
void dfs(int u,int fa)
{
    num[u]=1;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i].to;
        if(v==fa) continue;
        dp[v][1]=g[u][i].val;
        dfs(v,u);
        for(int j=num[u];j;j--)
        {
            for(int k=1;k<=num[v];k++)
            {
                dp[u][j+k]=max(dp[u][j+k],dp[u][j]+dp[v][k]);
            }
        }
        num[u]+=num[v];
    }
}
int main()
{
    std::ios::sync_with_stdio(false);
    while(cin>>n>>m)
    {
        memset(num,0,sizeof(num));
        memset(dp,0,sizeof(dp));
        m++;
        for(int i=0;i<n-1;i++)
        {
            int u,v,w;
            cin>>u>>v>>w;
            g[u].push_back({v,w});
            g[v].push_back({u,w});
        }
        dfs(1,0);
        cout<<dp[1][m]<<endl;
    }
    return 0;
}
4.牛客370F
题意:在一棵树中选一个点S，删除一些边使得所有叶子结点到达不了S。
思路:设dp[i]表示以i为根的子树的所有叶子到达不了i的最小代价。dp[u]+=min(dp[v],w),v为u的孩子，w为u-v的边权。
