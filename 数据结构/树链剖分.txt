1.点权
/*已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：
操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z
操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和
操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z
操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和
*/
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long
const int N=1e5+5;
const double eps=1e-8;
const double PI = acos(-1.0);
#define lowbit(x) (x&(-x))
int n,m,p,r;
int nxt[N<<1],to[N<<1],head[N<<1],tot;
int dep[N],fa[N],sz[N],son[N],id[N],cnt,wt[N],top[N];
void add(int u,int v)
{
    to[++tot]=v;
    nxt[tot]=head[u];
    head[u]=tot;
}
//以下为线段树
int sum[N<<2],lzy[N<<2];
int w[N];
void pushUp(int rt)
{
    sum[rt]=(sum[rt<<1]%p+sum[rt<<1|1]%p)%p;
}
void build(int l,int r,int rt)
{
    if(l==r)
    {
        sum[rt]=wt[l];
        return;
    }
    int m=(l+r)>>1;
    build(l,m,rt<<1);
    build(m+1,r,rt<<1|1);
    pushUp(rt);
}
void pushDown(int rt,int ln,int rn)
{
    if(lzy[rt])
    {
        lzy[rt<<1]+=lzy[rt]%p;
        lzy[rt<<1|1]+=lzy[rt]%p;
        sum[rt<<1]+=lzy[rt]*ln%p;
        sum[rt<<1|1]+=lzy[rt]*rn%p;
        lzy[rt]=0;
    }
}
void update(int L,int R,int C,int l,int r,int rt)
{
    if(L <= l && r <= R)
    {
        sum[rt]+=C*(r-l+1)%p;
        lzy[rt]+=C%p;
        return ;
    }
    int m=(l+r)>>1;
    pushDown(rt,m-l+1,r-m);
    if(L <= m) update(L,R,C,l,m,rt<<1);
    if(R >  m) update(L,R,C,m+1,r,rt<<1|1);
    pushUp(rt);
}
int query(int L,int R,int l,int r,int rt)
{
    if(L <= l && r <= R)
    {
        return sum[rt];
    }
    int m=(l+r)>>1;
    pushDown(rt,m-l+1,r-m);
    int ans=0;
    if(L <= m) ans+=query(L,R,l,m,rt<<1)%p;
    if(R >  m) ans+=query(L,R,m+1,r,rt<<1|1)%p;
    return ans%p;
}
//以上为线段树
void dfs1(int x,int f,int d)
{
    dep[x]=d;
    fa[x]=f;
    sz[x]=1;
    int mx=-1;
    for(int i=head[x]; i; i=nxt[i])
    {
        int y=to[i];
        if(y==f) continue;
        dfs1(y,x,d+1);
        sz[x]+=sz[y];
        if(sz[y]>mx) son[x]=y,mx=sz[y];
    }
}
void dfs2(int x,int topf)
{
    id[x]=++cnt;
    wt[cnt]=w[x];
    top[x]=topf;
    if(!son[x]) return ;
    dfs2(son[x],topf);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x]) continue;
        dfs2(y,y);
    }
}
int qRange(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ans+=query(id[top[x]],id[x],1,n,1);
        ans%=p;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    ans+=query(id[x],id[y],1,n,1);
    ans%=p;
    return ans;
}
void updRange(int x,int y,int z)
{
    z%=p;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        update(id[top[x]],id[x],z,1,n,1);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    update(id[x],id[y],z,1,n,1);
}
int qSon(int x)
{
    return query(id[x],id[x]+sz[x]-1,1,n,1);
}
void updSon(int x,int z)
{
    update(id[x],id[x]+sz[x]-1,z,1,n,1);
}
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);
    while(cin>>n>>m>>r>>p)
    {
        cnt=0,tot=0;
        memset(lzy,0,sizeof(lzy));
        memset(head,0,sizeof(head));
        for(int i=1;i<=n;i++)
        {
            cin>>w[i];
        }
        for(int i=1; i<n; i++)
        {
            int u,v;
            cin>>u>>v;
            add(u,v);
            add(v,u);
        }
        dfs1(r,0,1);
        dfs2(r,r);
        build(1,n,1);
        while(m--)
        {
            int op,x,y,z;
            cin>>op;
            if(op==1)
            {
                cin>>x>>y>>z;
                updRange(x,y,z);
            }
            else if(op==2)
            {
                cin>>x>>y;
                cout<<qRange(x,y)<<endl;
            }
            else if(op==3)
            {
                cin>>x>>y;
                updSon(x,y);
            }
            else
            {
                cin>>x;
                cout<<qSon(x)<<endl;
            }
        }
    }
    return 0;
}

2.边权
SPOJ - QTREE
两种操作，修改第i条边的边权，查询a到b路径的最大边权
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int inf = 0x3f3f3f3f, N = 1e4 + 5;
int n, m, T;

// 线段树
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
int mx[N << 2];
void pushUp(int rt)
{
    mx[rt] = max(mx[rt << 1], mx[rt << 1 | 1]);
}
void build(int l, int r, int rt)
{
    mx[rt] = 0;
    if (l == r) return;
    int m = (l + r) >> 1;
    build(lson);
    build(rson);
}
int query(int L, int R, int l, int r, int rt)
{
    if (L <= l && r <= R)
        return mx[rt];
    int m = (l + r) >> 1;
    int ret = 0;
    if (L <= m) ret = max(ret, query(L, R, lson));
    if (R > m) ret = max(ret, query(L, R, rson));
    return ret;
}
void update(int p, int x, int l, int r, int rt)
{
    if (l == r)
    {
        mx[rt] = x;
        return;
    }
    int m = (r + l) >> 1;
    if (p <= m) update(p, x, lson);
    else update(p, x, rson);
    pushUp(rt);
}

// 树链剖分
struct Edge
{
    int to, next;
} edge[N * 2];

int head[N], tot;
int top[N];  // top[v]即v所在重链的顶端结点
int fa[N];   // 父节点
int deep[N]; // 深度
int num[N];  // num[v] 以v为根的子树结点数
int p[N];    // p[v]为v的dfs位置
int fp[N];   // 与p相反
int son[N];  // 重子编号
int pos;

void init()
{
    tot = 0;
    pos = 0;
    memset(head,-1,sizeof(head));
    memset(son, -1,sizeof(son));
}

void add(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot++;
}

void dfs1(int u, int pre, int d)
{
    deep[u] = d;
    fa[u] = pre;
    num[u] = 1;
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].to;
        if (v != pre)
        {
            dfs1(v, u, d + 1);
            num[u] += num[v];
            if (son[u] == -1 || num[v] > num[son[u]])
                son[u] = v;
        }
    }
}

void dfs2(int u, int sp)
{
    top[u] = sp;
    p[u] = pos++;
    fp[p[u]] = u;
    if (son[u] == -1)
        return;
    dfs2(son[u], sp);
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].to;
        if (v != son[u] && v != fa[u])
            dfs2(v, v);
    }
}

// 查询u->v边的max
int queryMax(int u, int v)
{
    int f1 = top[u], f2 = top[v];
    int tmp = 0;
    while (f1 != f2)
    {
        if (deep[f1] < deep[f2])
        {
            swap(f1, f2);
            swap(u, v);
        }
        tmp = max(tmp, query(p[f1], p[u], 0, pos - 1, 1));
        u = fa[f1];
        f1 = top[u];
    }
    if (u == v) return tmp;
    if (deep[u] > deep[v]) swap(u, v);
    return max(tmp, query(p[son[u]], p[v], 0, pos - 1, 1));
}

int e[N][3];

// CHANGE i ti 修改第i条边的值为ti
// QUERY a b 询问a到b的最大边权
// DONE 结束符号
int main()
{
    scanf("%d", &T);
    while (T--)
    {
        init();
        scanf("%d", &n);
        for(int i=0; i<n-1; i++)
        {
            scanf("%d%d%d", &e[i][0], &e[i][1], &e[i][2]);
            add(e[i][0], e[i][1]);
            add(e[i][1], e[i][0]);
        }
        dfs1(1, 0, 0);
        dfs2(1, 1);
        build(0, pos - 1, 1);
        for(int i=0; i<n-1; i++)
        {
            if (deep[e[i][0]] > deep[e[i][1]])
                swap(e[i][0], e[i][1]);
            update(p[e[i][1]], e[i][2], 0, pos - 1, 1);
        }
        char op[10];
        int u, v;
        while (~scanf("%s", op))
        {
            if (op[0] == 'D') break;
            scanf("%d %d", &u, &v);
            if (op[0] == 'C')
                update(p[e[u - 1][1]], v, 0, pos - 1, 1);
            else
                printf("%d\n", queryMax(u, v));
        }
    }
    return 0;
}
