/*已知一棵包含N个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：
操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z
操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和
操作3： 格式： 3 x z 表示将以x为根节点的子树内所有节点值都加上z
操作4： 格式： 4 x 表示求以x为根节点的子树内所有节点值之和
*/
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
#define ll long long
const int N=1e5+5;
const double eps=1e-8;
const double PI = acos(-1.0);
#define lowbit(x) (x&(-x))
int n,m,p,r;
int nxt[N<<1],to[N<<1],head[N<<1],tot;
int dep[N],fa[N],sz[N],son[N],id[N],cnt,wt[N],top[N];
void add(int u,int v)
{
    to[++tot]=v;
    nxt[tot]=head[u];
    head[u]=tot;
}
//以下为线段树
int sum[N<<2],lzy[N<<2];
int w[N];
void pushUp(int rt)
{
    sum[rt]=(sum[rt<<1]%p+sum[rt<<1|1]%p)%p;
}
void build(int l,int r,int rt)
{
    if(l==r)
    {
        sum[rt]=wt[l];
        return;
    }
    int m=(l+r)>>1;
    build(l,m,rt<<1);
    build(m+1,r,rt<<1|1);
    pushUp(rt);
}
void pushDown(int rt,int ln,int rn)
{
    if(lzy[rt])
    {
        lzy[rt<<1]+=lzy[rt]%p;
        lzy[rt<<1|1]+=lzy[rt]%p;
        sum[rt<<1]+=lzy[rt]*ln%p;
        sum[rt<<1|1]+=lzy[rt]*rn%p;
        lzy[rt]=0;
    }
}
void update(int L,int R,int C,int l,int r,int rt)
{
    if(L <= l && r <= R)
    {
        sum[rt]+=C*(r-l+1)%p;
        lzy[rt]+=C%p;
        return ;
    }
    int m=(l+r)>>1;
    pushDown(rt,m-l+1,r-m);
    if(L <= m) update(L,R,C,l,m,rt<<1);
    if(R >  m) update(L,R,C,m+1,r,rt<<1|1);
    pushUp(rt);
}
int query(int L,int R,int l,int r,int rt)
{
    if(L <= l && r <= R)
    {
        return sum[rt];
    }
    int m=(l+r)>>1;
    pushDown(rt,m-l+1,r-m);
    int ans=0;
    if(L <= m) ans+=query(L,R,l,m,rt<<1)%p;
    if(R >  m) ans+=query(L,R,m+1,r,rt<<1|1)%p;
    return ans%p;
}
//以上为线段树
void dfs1(int x,int f,int d)
{
    dep[x]=d;
    fa[x]=f;
    sz[x]=1;
    int mx=-1;
    for(int i=head[x]; i; i=nxt[i])
    {
        int y=to[i];
        if(y==f) continue;
        dfs1(y,x,d+1);
        sz[x]+=sz[y];
        if(sz[y]>mx) son[x]=y,mx=sz[y];
    }
}
void dfs2(int x,int topf)
{
    id[x]=++cnt;
    wt[cnt]=w[x];
    top[x]=topf;
    if(!son[x]) return ;
    dfs2(son[x],topf);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(y==fa[x]||y==son[x]) continue;
        dfs2(y,y);
    }
}
int qRange(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ans+=query(id[top[x]],id[x],1,n,1);
        ans%=p;
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    ans+=query(id[x],id[y],1,n,1);
    ans%=p;
    return ans;
}
void updRange(int x,int y,int z)
{
    z%=p;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        update(id[top[x]],id[x],z,1,n,1);
        x=fa[top[x]];
    }
    if(dep[x]>dep[y]) swap(x,y);
    update(id[x],id[y],z,1,n,1);
}
int qSon(int x)
{
    return query(id[x],id[x]+sz[x]-1,1,n,1);
}
void updSon(int x,int z)
{
    update(id[x],id[x]+sz[x]-1,z,1,n,1);
}
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);
    while(cin>>n>>m>>r>>p)
    {
        cnt=0,tot=0;
        memset(lzy,0,sizeof(lzy));
        memset(head,0,sizeof(head));
        for(int i=1;i<=n;i++)
        {
            cin>>w[i];
        }
        for(int i=1; i<n; i++)
        {
            int u,v;
            cin>>u>>v;
            add(u,v);
            add(v,u);
        }
        dfs1(r,0,1);
        dfs2(r,r);
        build(1,n,1);
        while(m--)
        {
            int op,x,y,z;
            cin>>op;
            if(op==1)
            {
                cin>>x>>y>>z;
                updRange(x,y,z);
            }
            else if(op==2)
            {
                cin>>x>>y;
                cout<<qRange(x,y)<<endl;
            }
            else if(op==3)
            {
                cin>>x>>y;
                updSon(x,y);
            }
            else
            {
                cin>>x;
                cout<<qSon(x)<<endl;
            }
        }
    }
    return 0;
}
